<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChronoGuardians: Rift Defense</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: #00ffff;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            background: #0f0f23;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px;
            pointer-events: auto;
        }
        
        .top-left {
            top: 10px;
            left: 10px;
        }
        
        .top-right {
            top: 10px;
            right: 10px;
        }
        
        .bottom-center {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .tower-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.3s;
        }
        
        .tower-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px #00ffff;
        }
        
        .tower-btn.selected {
            background: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 15px #00ffff;
        }
        
        .skill-btn {
            width: 80px;
            height: 40px;
            background: rgba(255, 0, 255, 0.2);
            border: 2px solid #ff00ff;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            margin-top: 10px;
            transition: all 0.3s;
        }
        
        .skill-btn:hover {
            background: rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 10px #ff00ff;
        }
        
        .skill-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            max-width: 200px;
            z-index: 20;
            display: none;
        }
        
        .wave-info {
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="ui">
            <!-- Top Left Panel - Resources -->
            <div class="ui-panel top-left">
                <div>Core Health: <span id="coreHealth">100</span></div>
                <div>Credits: <span id="credits">150</span></div>
                <div>Aether Shards: <span id="aetherShards">3</span></div>
                <div>Wave: <span id="currentWave">1</span></div>
            </div>
            
            <!-- Top Right Panel - Controls -->
            <div class="ui-panel top-right">
                <div class="wave-info">
                    <div>Next Wave: <span id="nextWaveInfo">10 enemies</span></div>
                    <button id="startWaveBtn" style="margin-top: 5px; padding: 5px 10px; background: #00ffff; color: #000; border: none; border-radius: 3px; cursor: pointer;">Start Wave</button>
                </div>
                <button id="pauseBtn" style="margin-top: 10px; padding: 5px 10px; background: #ffff00; color: #000; border: none; border-radius: 3px; cursor: pointer;">Pause</button>
                
                <!-- Aether Skills -->
                <div style="margin-top: 15px; border-top: 1px solid #00ffff; padding-top: 10px;">
                    <div style="font-size: 12px; margin-bottom: 5px;">Aether Skills:</div>
                    <button class="skill-btn" id="overchargeBtn" data-cost="2">Overcharge<br>(2 Shards)</button>
                    <button class="skill-btn" id="aetherStormBtn" data-cost="3">Aether Storm<br>(3 Shards)</button>
                </div>
            </div>
            
            <!-- Bottom Panel - Tower Selection -->
            <div class="ui-panel bottom-center">
                <div class="tower-btn" data-tower="pulse" data-cost="50">
                    <div style="width: 20px; height: 20px; background: #00ffff; border-radius: 3px;"></div>
                    <div>Pulse</div>
                    <div>$50</div>
                </div>
                <div class="tower-btn" data-tower="beam" data-cost="75">
                    <div style="width: 20px; height: 20px; background: #00ff00; border-radius: 50%;"></div>
                    <div>Beam</div>
                    <div>$75</div>
                </div>
                <div class="tower-btn" data-tower="cryo" data-cost="60">
                    <div style="width: 20px; height: 20px; background: #87ceeb; border-radius: 3px;"></div>
                    <div>Cryo</div>
                    <div>$60</div>
                </div>
                <div class="tower-btn" data-tower="artillery" data-cost="100">
                    <div style="width: 20px; height: 20px; background: #ff6600; border-radius: 50%;"></div>
                    <div>Artillery</div>
                    <div>$100</div>
                </div>
                <div class="tower-btn" data-tower="aa" data-cost="80">
                    <div style="width: 20px; height: 20px; background: #ffff00; border-radius: 3px;"></div>
                    <div>AA Flak</div>
                    <div>$80</div>
                </div>
                <div class="tower-btn" data-tower="amplifier" data-cost="90">
                    <div style="width: 20px; height: 20px; background: #ff00ff; border-radius: 50%;"></div>
                    <div>Amplifier</div>
                    <div>$90</div>
                </div>
                <div class="tower-btn" data-tower="blocker" data-cost="25">
                    <div style="width: 20px; height: 20px; background: #808080; border-radius: 3px;"></div>
                    <div>Blocker</div>
                    <div>$25</div>
                </div>
            </div>
        </div>
        
        <div id="tooltip"></div>
    </div>
    
    <script>
        // Game Configuration
        const CONFIG = {
            GRID_SIZE: 40,
            CANVAS_WIDTH: 1200,
            CANVAS_HEIGHT: 800,
            GRID_WIDTH: 30,
            GRID_HEIGHT: 20,
            FPS: 60
        };
        
        // Game State
        class GameState {
            constructor() {
                this.credits = 150;
                this.aetherShards = 3;
                this.coreHealth = 100;
                this.currentWave = 0;
                this.gameRunning = false;
                this.selectedTowerType = null;
                this.towers = [];
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.grid = this.createGrid();
                this.path = this.generatePath();
                this.waveManager = new WaveManager();
                this.lastTime = 0;
            }
            
            createGrid() {
                const grid = [];
                for (let y = 0; y < CONFIG.GRID_HEIGHT; y++) {
                    grid[y] = [];
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        grid[y][x] = { walkable: true, tower: null };
                    }
                }
                return grid;
            }
            
            generatePath() {
                // Simple path from left to right with some turns
                return [
                    { x: 0, y: 10 },
                    { x: 5, y: 10 },
                    { x: 5, y: 5 },
                    { x: 15, y: 5 },
                    { x: 15, y: 15 },
                    { x: 25, y: 15 },
                    { x: 25, y: 10 },
                    { x: 29, y: 10 }
                ];
            }
        }
        
        // Vector2 utility class
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            distance(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            normalize() {
                const length = Math.sqrt(this.x * this.x + this.y * this.y);
                if (length > 0) {
                    this.x /= length;
                    this.y /= length;
                }
                return this;
            }
            
            multiply(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }
            
            add(other) {
                this.x += other.x;
                this.y += other.y;
                return this;
            }
            
            clone() {
                return new Vector2(this.x, this.y);
            }
        }
        
        // Object Pool for performance optimization
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 10) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(this.createFn());
                }
            }
            
            get() {
                if (this.pool.length > 0) {
                    return this.pool.pop();
                }
                return this.createFn();
            }
            
            release(obj) {
                this.resetFn(obj);
                this.pool.push(obj);
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(type, path) {
                this.type = type;
                this.path = path;
                this.pathIndex = 0;
                this.position = new Vector2(path[0].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2, 
                                          path[0].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2);
                this.target = new Vector2(path[1].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2, 
                                        path[1].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2);
                this.alive = true;
                this.reachedEnd = false;
                this.slowEffect = 1;
                this.slowDuration = 0;
                
                this.setupStats();
            }
            
            setupStats() {
                const stats = {
                    swarm: { health: 30, speed: 2, reward: 10, aether: 0, color: '#ff4444', size: 15 },
                    tank: { health: 150, speed: 0.8, reward: 25, aether: 0, color: '#ff8844', size: 25 },
                    sprinter: { health: 20, speed: 4, reward: 15, aether: 0, color: '#ff44ff', size: 12 },
                    support: { health: 80, speed: 1.5, reward: 20, aether: 1, color: '#8844ff', size: 20 },
                    air: { health: 60, speed: 2.5, reward: 18, aether: 0, color: '#44ffff', size: 18 },
                    boss: { health: 500, speed: 1, reward: 100, aether: 3, color: '#ff0000', size: 35 }
                };
                
                const stat = stats[this.type];
                this.maxHealth = stat.health;
                this.health = stat.health;
                this.speed = stat.speed;
                this.reward = stat.reward;
                this.aetherReward = stat.aether;
                this.color = stat.color;
                this.size = stat.size;
                this.isAir = this.type === 'air';
            }
            
            update(deltaTime) {
                if (!this.alive || this.reachedEnd) return;
                
                // Update slow effect
                if (this.slowDuration > 0) {
                    this.slowDuration -= deltaTime;
                    if (this.slowDuration <= 0) {
                        this.slowEffect = 1;
                    }
                }
                
                // Move towards target
                const direction = new Vector2(this.target.x - this.position.x, this.target.y - this.position.y);
                const distance = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
                
                if (distance < 5) {
                    this.pathIndex++;
                    if (this.pathIndex >= this.path.length - 1) {
                        this.reachedEnd = true;
                        return;
                    }
                    this.target = new Vector2(this.path[this.pathIndex + 1].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2,
                                            this.path[this.pathIndex + 1].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2);
                } else {
                    direction.normalize();
                    const moveSpeed = this.speed * this.slowEffect * deltaTime * 60;
                    this.position.add(direction.multiply(moveSpeed));
                }
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.alive = false;
                }
            }
            
            applySlow(factor, duration) {
                this.slowEffect = Math.min(this.slowEffect, factor);
                this.slowDuration = Math.max(this.slowDuration, duration);
            }
            
            render(ctx) {
                if (!this.alive) return;
                
                ctx.save();
                
                // Draw enemy
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                if (this.type === 'tank') {
                    ctx.fillRect(this.position.x - this.size/2, this.position.y - this.size/2, this.size, this.size);
                } else if (this.type === 'sprinter') {
                    ctx.beginPath();
                    ctx.moveTo(this.position.x + this.size/2, this.position.y);
                    ctx.lineTo(this.position.x - this.size/2, this.position.y - this.size/2);
                    ctx.lineTo(this.position.x - this.size/2, this.position.y + this.size/2);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Health bar
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.position.x - this.size/2, this.position.y - this.size/2 - 8, this.size, 4);
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
                ctx.fillRect(this.position.x - this.size/2, this.position.y - this.size/2 - 8, this.size * healthPercent, 4);
                
                ctx.restore();
            }
        }
        
        // Tower class
        class Tower {
            constructor(x, y, type) {
                this.gridX = x;
                this.gridY = y;
                this.position = new Vector2(x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2, 
                                          y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2);
                this.type = type;
                this.level = 1;
                this.target = null;
                this.lastFireTime = 0;
                this.setupStats();
            }
            
            setupStats() {
                const stats = {
                    pulse: { damage: 25, range: 120, fireRate: 1000, color: '#00ffff', canTargetAir: false },
                    beam: { damage: 15, range: 100, fireRate: 100, color: '#00ff00', canTargetAir: false },
                    cryo: { damage: 5, range: 80, fireRate: 500, color: '#87ceeb', canTargetAir: false },
                    artillery: { damage: 60, range: 150, fireRate: 2000, color: '#ff6600', canTargetAir: false },
                    aa: { damage: 40, range: 140, fireRate: 800, color: '#ffff00', canTargetAir: true },
                    amplifier: { damage: 0, range: 100, fireRate: 0, color: '#ff00ff', canTargetAir: false },
                    blocker: { damage: 0, range: 0, fireRate: 0, color: '#808080', canTargetAir: false }
                };
                
                const stat = stats[this.type];
                this.damage = stat.damage;
                this.range = stat.range;
                this.fireRate = stat.fireRate;
                this.color = stat.color;
                this.canTargetAir = stat.canTargetAir;
            }
            
            update(enemies, currentTime) {
                if (this.type === 'amplifier' || this.type === 'blocker') return;
                
                if (currentTime - this.lastFireTime >= this.fireRate) {
                    this.target = this.findTarget(enemies);
                    if (this.target) {
                        this.fire();
                        this.lastFireTime = currentTime;
                    }
                }
            }
            
            findTarget(enemies) {
                let bestTarget = null;
                let bestScore = -1;
                
                for (const enemy of enemies) {
                    if (!enemy.alive || enemy.reachedEnd) continue;
                    if (enemy.isAir && !this.canTargetAir) continue;
                    if (!enemy.isAir && this.type === 'aa') continue;
                    
                    const distance = this.position.distance(enemy.position);
                    if (distance <= this.range) {
                        // Prioritize enemies further along the path
                        const score = enemy.pathIndex + (1 - distance / this.range);
                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = enemy;
                        }
                    }
                }
                
                return bestTarget;
            }
            
            fire() {
                if (!this.target) return;
                
                if (this.type === 'pulse' || this.type === 'aa') {
                    game.projectiles.push(new Projectile(this.position.clone(), this.target, this.damage, this.type));
                } else if (this.type === 'beam') {
                    this.target.takeDamage(this.damage);
                    game.particles.push(new Particle(this.target.position.clone(), 'beam', this.color));
                } else if (this.type === 'cryo') {
                    this.target.takeDamage(this.damage);
                    this.target.applySlow(0.5, 2000);
                    game.particles.push(new Particle(this.target.position.clone(), 'cryo', this.color));
                } else if (this.type === 'artillery') {
                    // Area damage
                    for (const enemy of game.enemies) {
                        if (!enemy.alive || enemy.isAir) continue;
                        const distance = this.target.position.distance(enemy.position);
                        if (distance <= 60) {
                            const damage = this.damage * (1 - distance / 60);
                            enemy.takeDamage(damage);
                        }
                    }
                    game.particles.push(new Particle(this.target.position.clone(), 'explosion', this.color));
                }
            }
            
            upgrade() {
                if (this.level >= 3) return false;
                
                this.level++;
                this.damage *= 1.5;
                this.range *= 1.2;
                this.fireRate *= 0.8;
                
                return true;
            }
            
            getUpgradeCost() {
                return Math.floor(this.getBaseCost() * Math.pow(1.5, this.level - 1));
            }
            
            getBaseCost() {
                const costs = {
                    pulse: 50, beam: 75, cryo: 60, artillery: 100,
                    aa: 80, amplifier: 90, blocker: 25
                };
                return costs[this.type] || 50;
            }
            
            render(ctx) {
                ctx.save();
                
                // Draw tower base
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                
                const size = 25 + (this.level - 1) * 5;
                
                if (this.type === 'blocker') {
                    ctx.fillRect(this.position.x - size/2, this.position.y - size/2, size, size);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Level indicator
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.level.toString(), this.position.x, this.position.y + 4);
                }
                
                ctx.restore();
            }
            
            renderRange(ctx) {
                if (this.range <= 0) return;
                
                ctx.save();
                ctx.strokeStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.range, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Projectile class
        class Projectile {
            constructor(position, target, damage, type) {
                this.position = position;
                this.target = target;
                this.damage = damage;
                this.type = type;
                this.speed = 300;
                this.alive = true;
                
                // Calculate direction
                this.direction = new Vector2(target.position.x - position.x, target.position.y - position.y);
                this.direction.normalize();
            }
            
            update(deltaTime) {
                if (!this.alive || !this.target.alive) {
                    this.alive = false;
                    return;
                }
                
                // Move towards target
                const moveDistance = this.speed * deltaTime;
                this.position.add(this.direction.clone().multiply(moveDistance));
                
                // Check collision
                const distance = this.position.distance(this.target.position);
                if (distance < 10) {
                    this.target.takeDamage(this.damage);
                    game.particles.push(new Particle(this.position.clone(), 'hit', '#ffff00'));
                    this.alive = false;
                }
            }
            
            render(ctx) {
                if (!this.alive) return;
                
                ctx.save();
                ctx.fillStyle = this.type === 'aa' ? '#ffff00' : '#00ffff';
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Particle class for visual effects
        class Particle {
            constructor(position, type, color) {
                this.position = position;
                this.type = type;
                this.color = color;
                this.life = 1.0;
                this.maxLife = 1.0;
                this.size = 5;
                this.velocity = new Vector2(0, 0);
                
                if (type === 'explosion') {
                    this.size = 30;
                    this.maxLife = 0.5;
                    this.life = 0.5;
                } else if (type === 'hit') {
                    this.size = 8;
                    this.maxLife = 0.3;
                    this.life = 0.3;
                }
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                
                if (this.type === 'explosion') {
                    this.size += deltaTime * 60;
                }
                
                return this.life <= 0;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Wave Manager
        class WaveManager {
            constructor() {
                this.currentWave = 0;
                this.waveInProgress = false;
                this.enemiesSpawned = 0;
                this.enemiesToSpawn = 0;
                this.spawnTimer = 0;
                this.spawnInterval = 1000;
            }
            
            startWave() {
                if (this.waveInProgress) return;
                
                this.currentWave++;
                this.waveInProgress = true;
                this.enemiesSpawned = 0;
                this.enemiesToSpawn = Math.floor(5 + this.currentWave * 2.5);
                this.spawnTimer = 0;
                this.spawnInterval = Math.max(300, 1000 - this.currentWave * 20);
                
                game.updateUI();
            }
            
            update(deltaTime) {
                if (!this.waveInProgress) return;
                
                this.spawnTimer += deltaTime * 1000;
                
                if (this.spawnTimer >= this.spawnInterval && this.enemiesSpawned < this.enemiesToSpawn) {
                    this.spawnEnemy();
                    this.spawnTimer = 0;
                }
                
                // Check if wave is complete
                if (this.enemiesSpawned >= this.enemiesToSpawn && game.enemies.length === 0) {
                    this.completeWave();
                }
            }
            
            spawnEnemy() {
                const types = ['swarm', 'tank', 'sprinter', 'support', 'air'];
                let type;
                
                // Boss every 10 waves
                if (this.currentWave % 10 === 0 && this.enemiesSpawned === this.enemiesToSpawn - 1) {
                    type = 'boss';
                } else {
                    // Weighted random selection
                    const rand = Math.random();
                    if (rand < 0.4) type = 'swarm';
                    else if (rand < 0.6) type = 'tank';
                    else if (rand < 0.75) type = 'sprinter';
                    else if (rand < 0.9) type = 'support';
                    else type = 'air';
                }
                
                const enemy = new Enemy(type, game.path);
                game.enemies.push(enemy);
                this.enemiesSpawned++;
            }
            
            completeWave() {
                this.waveInProgress = false;
                
                // Wave completion rewards
                const creditReward = 50 + this.currentWave * 10;
                const aetherReward = Math.floor(this.currentWave / 3);
                
                game.credits += creditReward;
                game.aetherShards += aetherReward;
                
                game.updateUI();
            }
            
            getNextWaveInfo() {
                const nextWave = this.currentWave + 1;
                const enemyCount = Math.floor(5 + nextWave * 2.5);
                return `Wave ${nextWave}: ${enemyCount} enemies`;
            }
        }
        
        // A* Pathfinding
        class Pathfinder {
            static findPath(start, end, grid) {
                const openSet = [start];
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();
                
                gScore.set(this.nodeKey(start), 0);
                fScore.set(this.nodeKey(start), this.heuristic(start, end));
                
                while (openSet.length > 0) {
                    // Find node with lowest fScore
                    let current = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (fScore.get(this.nodeKey(openSet[i])) < fScore.get(this.nodeKey(current))) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }
                    
                    if (current.x === end.x && current.y === end.y) {
                        // Reconstruct path
                        const path = [];
                        let node = current;
                        while (node) {
                            path.unshift(node);
                            node = cameFrom.get(this.nodeKey(node));
                        }
                        return path;
                    }
                    
                    openSet.splice(currentIndex, 1);
                    closedSet.add(this.nodeKey(current));
                    
                    // Check neighbors
                    const neighbors = this.getNeighbors(current, grid);
                    for (const neighbor of neighbors) {
                        const neighborKey = this.nodeKey(neighbor);
                        
                        if (closedSet.has(neighborKey)) continue;
                        
                        const tentativeGScore = gScore.get(this.nodeKey(current)) + 1;
                        
                        if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                            openSet.push(neighbor);
                        } else if (tentativeGScore >= gScore.get(neighborKey)) {
                            continue;
                        }
                        
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor, end));
                    }
                }
                
                return null; // No path found
            }
            
            static nodeKey(node) {
                return `${node.x},${node.y}`;
            }
            
            static heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }
            
            static getNeighbors(node, grid) {
                const neighbors = [];
                const directions = [{x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0}];
                
                for (const dir of directions) {
                    const x = node.x + dir.x;
                    const y = node.y + dir.y;
                    
                    if (x >= 0 && x < CONFIG.GRID_WIDTH && y >= 0 && y < CONFIG.GRID_HEIGHT) {
                        if (grid[y][x].walkable) {
                            neighbors.push({x, y});
                        }
                    }
                }
                
                return neighbors;
            }
        }
        
        // Main Game class
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = new GameState();
                
                // Copy state properties for easier access
                Object.assign(this, this.state);
                
                this.selectedTower = null;
                this.hoveredTile = null;
                this.showingRange = false;
                
                this.setupEventListeners();
                this.updateUI();
                this.gameLoop();
            }
            
            setupEventListeners() {
                // Canvas mouse events
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.handleRightClick(e);
                });
                
                // UI button events
                document.getElementById('startWaveBtn').addEventListener('click', () => {
                    this.waveManager.startWave();
                });
                
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.gameRunning = !this.gameRunning;
                    document.getElementById('pauseBtn').textContent = this.gameRunning ? 'Pause' : 'Resume';
                });
                
                // Tower selection buttons
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const towerType = btn.dataset.tower;
                        const cost = parseInt(btn.dataset.cost);
                        
                        if (this.credits >= cost) {
                            this.selectedTowerType = towerType;
                            this.updateTowerButtons();
                        }
                    });
                    
                    // Tooltip
                    btn.addEventListener('mouseenter', (e) => this.showTooltip(e, towerType));
                    btn.addEventListener('mouseleave', () => this.hideTooltip());
                });
                
                // Skill buttons
                document.getElementById('overchargeBtn').addEventListener('click', () => {
                    this.useSkill('overcharge');
                });
                
                document.getElementById('aetherStormBtn').addEventListener('click', () => {
                    this.useSkill('aetherStorm');
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.gameRunning = !this.gameRunning;
                        document.getElementById('pauseBtn').textContent = this.gameRunning ? 'Pause' : 'Resume';
                    } else if (e.code === 'Escape') {
                        this.selectedTowerType = null;
                        this.selectedTower = null;
                        this.updateTowerButtons();
                    }
                });
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const gridX = Math.floor(x / CONFIG.GRID_SIZE);
                const gridY = Math.floor(y / CONFIG.GRID_SIZE);
                
                this.hoveredTile = { x: gridX, y: gridY };
                
                // Check if hovering over a tower
                this.selectedTower = null;
                for (const tower of this.towers) {
                    if (tower.gridX === gridX && tower.gridY === gridY) {
                        this.selectedTower = tower;
                        break;
                    }
                }
                
                this.showingRange = this.selectedTower !== null || this.selectedTowerType !== null;
            }
            
            handleClick(e) {
                if (!this.hoveredTile) return;
                
                const { x, y } = this.hoveredTile;
                
                // Check if clicking on existing tower
                for (const tower of this.towers) {
                    if (tower.gridX === x && tower.gridY === y) {
                        this.upgradeTower(tower);
                        return;
                    }
                }
                
                // Place new tower
                if (this.selectedTowerType && this.canPlaceTower(x, y)) {
                    this.placeTower(x, y, this.selectedTowerType);
                }
            }
            
            handleRightClick(e) {
                if (!this.hoveredTile) return;
                
                const { x, y } = this.hoveredTile;
                
                // Remove tower
                for (let i = 0; i < this.towers.length; i++) {
                    if (this.towers[i].gridX === x && this.towers[i].gridY === y) {
                        const tower = this.towers[i];
                        this.credits += Math.floor(tower.getBaseCost() * 0.7);
                        this.towers.splice(i, 1);
                        this.grid[y][x].tower = null;
                        
                        // Recalculate path if blocker was removed
                        if (tower.type === 'blocker') {
                            this.updatePath();
                        }
                        
                        this.updateUI();
                        break;
                    }
                }
            }
            
            canPlaceTower(x, y) {
                if (x < 0 || x >= CONFIG.GRID_WIDTH || y < 0 || y >= CONFIG.GRID_HEIGHT) return false;
                if (this.grid[y][x].tower) return false;
                
                // Check if on path
                for (const pathNode of this.path) {
                    if (pathNode.x === x && pathNode.y === y) return false;
                }
                
                // If placing a blocker, check if it would block all paths
                if (this.selectedTowerType === 'blocker') {
                    this.grid[y][x].walkable = false;
                    const testPath = Pathfinder.findPath(this.path[0], this.path[this.path.length - 1], this.grid);
                    this.grid[y][x].walkable = true;
                    
                    if (!testPath) return false;
                }
                
                return true;
            }
            
            placeTower(x, y, type) {
                const costs = {
                    pulse: 50, beam: 75, cryo: 60, artillery: 100,
                    aa: 80, amplifier: 90, blocker: 25
                };
                
                const cost = costs[type];
                if (this.credits < cost) return;
                
                const tower = new Tower(x, y, type);
                this.towers.push(tower);
                this.grid[y][x].tower = tower;
                this.credits -= cost;
                
                if (type === 'blocker') {
                    this.grid[y][x].walkable = false;
                    this.updatePath();
                }
                
                this.selectedTowerType = null;
                this.updateTowerButtons();
                this.updateUI();
            }
            
            upgradeTower(tower) {
                const cost = tower.getUpgradeCost();
                if (this.credits >= cost && tower.upgrade()) {
                    this.credits -= cost;
                    this.updateUI();
                }
            }
            
            updatePath() {
                // Recalculate path using A*
                const start = this.path[0];
                const end = this.path[this.path.length - 1];
                const newPath = Pathfinder.findPath(start, end, this.grid);
                
                if (newPath) {
                    this.path = newPath;
                    
                    // Update all ground enemies to use new path
                    for (const enemy of this.enemies) {
                        if (!enemy.isAir) {
                            enemy.path = this.path;
                            // Reset to closest path point
                            let closestIndex = 0;
                            let closestDistance = Infinity;
                            
                            for (let i = 0; i < this.path.length; i++) {
                                const pathPos = new Vector2(this.path[i].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2,
                                                           this.path[i].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2);
                                const distance = enemy.position.distance(pathPos);
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestIndex = i;
                                }
                            }
                            
                            enemy.pathIndex = Math.max(0, closestIndex - 1);
                            if (enemy.pathIndex < this.path.length - 1) {
                                enemy.target = new Vector2(this.path[enemy.pathIndex + 1].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2,
                                                          this.path[enemy.pathIndex + 1].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2);
                            }
                        }
                    }
                }
            }
            
            useSkill(skillType) {
                if (skillType === 'overcharge' && this.aetherShards >= 2) {
                    this.aetherShards -= 2;
                    // Implement overcharge effect
                    setTimeout(() => {
                        // Effect ends after 10 seconds
                    }, 10000);
                } else if (skillType === 'aetherStorm' && this.aetherShards >= 3) {
                    this.aetherShards -= 3;
                    // Damage all enemies
                    for (const enemy of this.enemies) {
                        enemy.takeDamage(100);
                        this.particles.push(new Particle(enemy.position.clone(), 'hit', '#ff00ff'));
                    }
                }
                
                this.updateUI();
            }
            
            showTooltip(e, towerType) {
                const tooltip = document.getElementById('tooltip');
                const descriptions = {
                    pulse: 'Pulse Cannon\nDamage: 25\nRange: 120\nTargets: Ground',
                    beam: 'Beam Laser\nDamage: 15 (continuous)\nRange: 100\nTargets: Ground',
                    cryo: 'Cryo Tower\nDamage: 5\nRange: 80\nEffect: Slows enemies\nTargets: Ground',
                    artillery: 'Artillery\nDamage: 60 (AoE)\nRange: 150\nTargets: Ground',
                    aa: 'AA Flak\nDamage: 40\nRange: 140\nTargets: Air only',
                    amplifier: 'Amplifier\nBoosts nearby towers\nRange: 100\nTargets: None',
                    blocker: 'Blocker Post\nBlocks enemy path\nHealth: High\nTargets: None'
                };
                
                tooltip.innerHTML = descriptions[towerType].replace(/\n/g, '<br>');
                tooltip.style.display = 'block';
                tooltip.style.left = e.pageX + 10 + 'px';
                tooltip.style.top = e.pageY + 10 + 'px';
            }
            
            hideTooltip() {
                document.getElementById('tooltip').style.display = 'none';
            }
            
            updateTowerButtons() {
                document.querySelectorAll('.tower-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    if (btn.dataset.tower === this.selectedTowerType) {
                        btn.classList.add('selected');
                    }
                });
            }
            
            updateUI() {
                document.getElementById('coreHealth').textContent = this.coreHealth;
                document.getElementById('credits').textContent = this.credits;
                document.getElementById('aetherShards').textContent = this.aetherShards;
                document.getElementById('currentWave').textContent = this.waveManager.currentWave;
                document.getElementById('nextWaveInfo').textContent = this.waveManager.getNextWaveInfo();
                
                // Update skill buttons
                const overchargeBtn = document.getElementById('overchargeBtn');
                const aetherStormBtn = document.getElementById('aetherStormBtn');
                
                overchargeBtn.classList.toggle('disabled', this.aetherShards < 2);
                aetherStormBtn.classList.toggle('disabled', this.aetherShards < 3);
            }
            
            update(deltaTime) {
                if (!this.gameRunning) return;
                
                // Update wave manager
                this.waveManager.update(deltaTime);
                
                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update(deltaTime);
                    
                    if (!enemy.alive) {
                        this.credits += enemy.reward;
                        this.aetherShards += enemy.aetherReward;
                        this.particles.push(new Particle(enemy.position.clone(), 'explosion', enemy.color));
                        this.enemies.splice(i, 1);
                    } else if (enemy.reachedEnd) {
                        this.coreHealth -= 10;
                        this.enemies.splice(i, 1);
                        
                        if (this.coreHealth <= 0) {
                            this.gameOver();
                        }
                    }
                }
                
                // Update towers
                const currentTime = Date.now();
                for (const tower of this.towers) {
                    tower.update(this.enemies, currentTime);
                }
                
                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    projectile.update(deltaTime);
                    
                    if (!projectile.alive) {
                        this.projectiles.splice(i, 1);
                    }
                }
                
                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    if (particle.update(deltaTime)) {
                        this.particles.splice(i, 1);
                    }
                }
                
                this.updateUI();
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0f0f23';
                this.ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                
                // Draw grid
                this.ctx.strokeStyle = '#1a1a3a';
                this.ctx.lineWidth = 1;
                for (let x = 0; x <= CONFIG.CANVAS_WIDTH; x += CONFIG.GRID_SIZE) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, CONFIG.CANVAS_HEIGHT);
                    this.ctx.stroke();
                }
                for (let y = 0; y <= CONFIG.CANVAS_HEIGHT; y += CONFIG.GRID_SIZE) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(CONFIG.CANVAS_WIDTH, y);
                    this.ctx.stroke();
                }
                
                // Draw path
                this.ctx.strokeStyle = '#444466';
                this.ctx.lineWidth = 20;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.beginPath();
                for (let i = 0; i < this.path.length; i++) {
                    const x = this.path[i].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                    const y = this.path[i].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Draw spawn and end points
                this.ctx.fillStyle = '#00ff00';
                this.ctx.shadowColor = '#00ff00';
                this.ctx.shadowBlur = 15;
                const startX = this.path[0].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                const startY = this.path[0].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                this.ctx.beginPath();
                this.ctx.arc(startX, startY, 15, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#ff0000';
                this.ctx.shadowColor = '#ff0000';
                const endX = this.path[this.path.length - 1].x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                const endY = this.path[this.path.length - 1].y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, 15, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Reset shadow
                this.ctx.shadowBlur = 0;
                
                // Draw towers
                for (const tower of this.towers) {
                    tower.render(this.ctx);
                }
                
                // Draw range for selected tower or tower type
                if (this.showingRange) {
                    if (this.selectedTower) {
                        this.selectedTower.renderRange(this.ctx);
                    } else if (this.selectedTowerType && this.hoveredTile) {
                        const tempTower = new Tower(this.hoveredTile.x, this.hoveredTile.y, this.selectedTowerType);
                        tempTower.renderRange(this.ctx);
                    }
                }
                
                // Draw placement preview
                if (this.selectedTowerType && this.hoveredTile && this.canPlaceTower(this.hoveredTile.x, this.hoveredTile.y)) {
                    const x = this.hoveredTile.x * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                    const y = this.hoveredTile.y * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE/2;
                    
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    this.ctx.fillRect(this.hoveredTile.x * CONFIG.GRID_SIZE, this.hoveredTile.y * CONFIG.GRID_SIZE, CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
                }
                
                // Draw enemies
                for (const enemy of this.enemies) {
                    enemy.render(this.ctx);
                }
                
                // Draw projectiles
                for (const projectile of this.projectiles) {
                    projectile.render(this.ctx);
                }
                
                // Draw particles
                for (const particle of this.particles) {
                    particle.render(this.ctx);
                }
                
                // Draw hovered tile highlight
                if (this.hoveredTile) {
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(this.hoveredTile.x * CONFIG.GRID_SIZE, this.hoveredTile.y * CONFIG.GRID_SIZE, CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
                }
            }
            
            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            gameOver() {
                this.gameRunning = false;
                alert('Game Over! Your core has been destroyed.');
                // Reset game or show game over screen
            }
        }
        
        // Initialize game
        let game;
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>